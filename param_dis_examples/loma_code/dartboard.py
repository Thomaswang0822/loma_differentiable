def score_integrand_pd(loc_x: In[float], dist_t: In[float]) -> float:
    if loc_x < dist_t:
        return 8.0  # in good (high-score) region
    else:
        return 1.0  # in bad (low-score) region


fwd_score_integrand_pd = fwd_diff(score_integrand_pd)
#### score_eval_pd() will be generated by compiler
# def score_eval_pd(lower: In[float], upper: In[float], t: In[float]) -> float:
#     curr_x: float = lower
#     n: int = (upper - lower) / 0.01 + 1
#     i: int = 0
#     res: float = 0.0
#     while (i < n, max_iter := 10000):
#         res = res + score_integrand_pd(curr_x, t)
#         i = i + 1
#         curr_x = curr_x + 0.01
#     res = res * (upper - lower) / n
#     return res
fwd_score_eval_pd = fwd_diff(score_eval_pd)

def good_bad_diff(radius: In[float], curr_t: In[float]) -> float:
    zero: float = 0.0
    total_area: float = score_eval_pd(zero, radius, curr_t) * 6.283
    # manually compute area of high-score region
    good_area: float = 3.1415 * curr_t * curr_t * 8.0
    # effectively good - bad
    area_diff: float = 2.0 * good_area - total_area
    return area_diff

fwd_good_bad_diff = fwd_diff(good_bad_diff)